这几天了解了一下三叉树，以及如何创建一个平衡的三叉树。
简单总结一下我学习到的三叉树
三叉树，顾名思义，就是每个节点都有三个分支的树，既左节点、中节点和右节点。
每个节点仅储存一个字符，父节点只与它的直接后继节点相关。
举个例子：
reach、read在三叉树中的结构
        r
        e
        a
        d c
          h
这样，从上往下读就可以得到read和reach。
需要注意的是，可能会出现一个词是另一个词的组成部分这样的情况，因此还需要在节点中添加一个属性，以判断当前节点是否是一个终节点。
这个属性可以是任何类型，毕竟我们可以用这个属性是否为null用来判断。
另外，在储存这些词时，应当遵循一定的规则，比如这里的c放在了a的右节点而不是左节点，就是因为c按字母顺序排在a的后方，而不是前方。
这样才能保证历遍时一定能找到想要的词。

关于平衡的三叉树
所谓平衡大概是指按某种规则对词条(注意，此处指的是一个完整的词，而非字母)进行排序，以提升搜索效率。
不太好总结，诸位可以参考https://blog.csdn.net/shen_gang/article/details/17692769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-17692769-blog-4234840.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-17692769-blog-4234840.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=1

三叉树的生成方案：
一上午的成果，
基于outputBalanced算法(见上面的网址)
首先对数组排序
检查根节点是否为空
如果根节点为空
则以当前词条的首字母生成一个新节点作为根节点
否则
从根节点开始检索
#每匹配到一个字符
#移除掉当前词条的对应字符
#如果不匹配
#那么检测当前词条的首字母按顺序应当排在当前节点字母的左边还是右边
#如果是左边
#则继续历遍左子树
#否则历遍右子树
重复#流程直到当前节点为null
在此处生成一个新的节点
剩余字母作为该节点的中节点
由于部分词条还需要展示别的内容，
因此还需添加一个内容属性，
该属性可以作为断点以避免一个词是另一个词的组成部分的问题
此内容属性与数据库关联，
如果内容属性为空，则证明当前节点并不是一个完整的词。由于每个词条的类都不一定相同，因此建议使用父类代替。

